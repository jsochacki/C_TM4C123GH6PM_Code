/*
 * Synth_API_Register_Programming.c
 *
 * Author: Mason Edgar
 *
 */


#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include "inc/tm4c123gh6pm.h"
#include "inc/hw_adc.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_gpio.h"
#include "inc/hw_types.h"
#include "inc/hw_ssi.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/timer.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/debug.h"
#include "driverlib/adc.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/pwm.h"
#include "driverlib/ssi.h"
#include "Synth_API_Macro_Definitions.h"
#include "Synth_API_Register_Programming.h"











void SetupChargePump(unsigned long icp_pmos, unsigned long icp_nmos, bool CP_HiZ, unsigned long icp_bleeder){


/*

                                                             Charge Pump Control Register Map

  +----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
  |                |                |                |                |                |                |                |                |                |
  |      ADDR      |       D7       |       D6       |       D5       |       D4       |       D3       |       D2       |       D1       |       D0       |
  |                |                |                |                |                |                |                |                |                |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                |                |                |                |                |                |                |                |                |
  |      002D      |     UNUSED     |     UNUSED     |   Icp_pmos<5>  |   Icp_pmos<4>  |   Icp_pmos<3>  |   Icp_pmos<2>  |   Icp_pmos<1>  |   Icp_pmos<0>  |
  |                |                |                |                |                |                |                |                |                |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                |                |                |                |                |                |                |                |                |
  |      002E      |     UNUSED     |     UNUSED     |   Icp_nmos<5>  |   Icp_nmos<4>  |   Icp_nmos<3>  |   Icp_nmos<2>  |   Icp_nmos<1>  |   Icp_nmos<0>  |
  |                |                |                |                |                |                |                |                |                |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                |                |                |                |                |                |                |                |                |
  |      002F      |     UNUSED     |     UNUSED     |     CP_HiZ     | Icp_bleeder<4> | Icp_bleeder<3> | Icp_bleeder<2> | Icp_bleeder<1> | Icp_bleeder<0> |
  |                |                |                |                |                |                |                |                |                |
  +----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+


 In order to put the charge pump into three-state mode, the user must set the bits CP_HiZ (Bit D5) to 1 in Register 47d in the Charge Pump Control Registers.

 This bit should be set to 0 for normal operation.

________________________________________________

 Charge Pump Pmos Current Setting:

 00 0000 = 166 uA

 00 0001 = 333 uA

 ...

 01 1101 = 5 mA (default)

 ...

 11 1111 = 10.66 mA

________________________________________________

 Charge Pump Nmos Current Setting

 00 0000 = 166 uA

 00 0001 = 333 uA

 ...

 01 1101 = 5 mA (default)

 ...

 01 1111 = 10.66 mA

________________________________________________

 Charge Pump High-Impedance Control

 0 = Charge Pump Active

 1 = Charge Pump High-Impedance



 Charge Pump High Impedance Macros:

 CP_HIGH_Z 0x00000020

________________________________________________

 Charge Pump Bleeder Current Setting

 0 0000 = Off (0 uA) (Default)

 0 0001 = 5.3 uA

 0 0010 = 10.6 uA

 ...

 1 1111 = 166 uA

________________________________________________

*/


	unsigned long icp_pmos_word, icp_nmos_word, icp_bleeder_word, bleeder_with_HiZ;

	icp_pmos_word = Create24BitWord(icp_pmos, REG_2Dh);
	icp_nmos_word = Create24BitWord(icp_nmos, REG_2Eh);


	if(CP_HiZ){

		bleeder_with_HiZ = icp_bleeder | CP_HIGH_Z;

		icp_bleeder_word = Create24BitWord(bleeder_with_HiZ, REG_2Fh);
	}

	else{

		icp_bleeder_word = Create24BitWord(icp_bleeder, REG_2Fh);
	}


	sendWord_24Bit(icp_pmos_word);
	sendWord_24Bit(icp_nmos_word);
	sendWord_24Bit(icp_bleeder_word);

}



void SetupOutputControl(bool QA_enable, unsigned long QA_power, bool QB_enable, unsigned long QB_power, bool MuteUntil_LockDetect, bool OutDoublerEnable, unsigned long OutDivider){

/*

  The 8V97003 device provides two differential outputs. These two outputs generate the same frequency equal to f_VCO when bypassing the optional output doubler
  and the optional output divider M0, or to 2 × f_VCO (up to 18GHz) when using the optional output doubler, or an integer division of the VCO frequency f_VCO.
  The division ratios of the output divider are provided in the Outputs Control Registers (see below).

  Each output buffer RF_OUTA and RF_OUTB offer a programmable RF output power. The programmable output power settings can be selected from -2dBm to +12dBm with steps of 2dBm.
  The RF output power can be programmed via the bits QA_pwr[7:0] and QB_pwr[7:0].

  The 8V97003 offers an auxiliary output (RF_OUTB). If the auxiliary output stage is not used, it can be powered down by using the QB_Ena bit in the Outputs Control Registers
  (refer to below register map). The outputs can be disabled until the part achieves lock. To enable this mode, the user will set the Mute_until_LD bit in the Outputs Control
  Registers (refer to below register map). The MUTE pin can be used to mute all outputs and be used as a similar function.


                                                               Output Control Register Map

  +---------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
  |               |                |                |                |                |                |                |                |                |
  |     ADDR      |       D7       |       D6       |       D5       |       D4       |       D3       |       D2       |       D1       |       D0       |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0033      |    QA_pwr<7>   |    QA_pwr<6>   |    QA_pwr<5>   |    QA_pwr<4>   |    QA_pwr<3>   |    QA_pwr<2>   |    QA_pwr<1>   |    QA_pwr<0>   |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0034      |       0        |     UNUSED     | Mute_Until_LD  |     QA_ena     |       1        |       0        |       0        |       0        |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0035      |   QB_pwr<7>    |    QB_pwr<6>   |    QB_pwr<5>   |    QB_pwr<4>   |    QB_pwr<3>   |    QB_pwr<2>   |    QB_pwr<1>   |    QB_pwr<0>   |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0036      |       0        |     UNUSED     |     UNUSED     |     QB_ena     |       1        |       0        |       0        |       0        |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0037      |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0038      |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     0039      |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     003A      |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |    RESERVED    |
  |               |                |                |                |                |                |                |                |                |
  +-------------------------------------------------------------------------------------------------------------------------------------------------------+
  |               |                |                |                |                |                |                |                |                |
  |     003B      | OutDoubler_Ena |     UNUSED     |     UNUSED     |     UNUSED     |     UNUSED     |   OutDiv <2>   |   OutDiv <1>   |   OutDiv <0>   |
  |               |                |                |                |                |                |                |                |                |
  +---------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+


__________________________________________________________________________________

 QA_Power:

 RF_OUTA Power Setting

 0000 0000 = OFF (Default)
 0000 0001 = -2dBm
 0000 0011 = 0dBm
 0000 0111 = +2dBm
 0000 1111 = +4dBm
 0001 1111 = +6dBm
 0011 1111 = +8dBm
 0111 1111 = +10dBm
 1111 1111 = +12dBm

__________________________________________________________________________________

 QA_ena:

 RF_OUTA Enable

 0 = RF_OUTA is OFF (Default)
 1 = RF_OUTA is Enabled

__________________________________________________________________________________

 QB_Power:

 RF_OUTB Power Setting

 0000 0000 = OFF (Default)
 0000 0001 = -2dBm
 0000 0011 = 0dBm
 0000 0111 = +2dBm
 0000 1111 = +4dBm
 0001 1111 = +6dBm
 0011 1111 = +8dBm
 0111 1111 = +10dBm
 1111 1111 = +12dBm

__________________________________________________________________________________

 QB_ena:

 RF_OUTB Enable

 0 = RF_OUTB is OFF (Default)
 1 = RF_OUTB is Enabled

__________________________________________________________________________________

 Mute_Until_LD:

 Mute until Lock Detect selection

 0: Outputs are enabled independent of Lock Detect (Default)
 1: Outputs are enabled only when Lock Detect is high

__________________________________________________________________________________

 Out_Doubler_Ena:

 RF Output Doubler Enable

 0 = RF Output Doubler Disabled (default)
 1 = RF Output Doubler Enabled

 OutDoubler_Ena may only be set to 1 if the VCO frequency is not greater than 9GHz.

__________________________________________________________________________________

 OutDivider:

 RF Output Divider Settings

 000 = Divide By 1
 001 = Divide By 2
 010 = Divide By 4
 011 = Divide By 8
 100 = Divide By 16
 101 = Divide By 32
 110 = Unused
 111 = Unused

__________________________________________________________________________________


*/


	if(QA_enable){

		unsigned long QA_power_word, QA_enable_word;

		QA_power_word = Create24BitWord(QA_power, REG_33h);

		sendWord_24Bit(QA_power_word);

		if(MuteUntil_LockDetect){ QA_enable_word = Create24BitWord(QA_ENABLE_MUTE_UNTIL_LOCK_DETECT, REG_34h); }

		else{ QA_enable_word = Create24BitWord(QA_ENABLE_NO_MUTE, REG_34h); }

		sendWord_24Bit(QA_enable_word);

	}

	if(QB_enable){

		unsigned long QB_power_word, QB_enable_word, Enable_MuteUntilLockDetect_WithoutQA_word, Disable_MuteUntilLockDetect_WithoutQA_word;

		QB_power_word = Create24BitWord(QB_power, REG_35h);

		sendWord_24Bit(QB_power_word);

		if(QA_enable){

			// QA already set the MuteUntilLockDetect bit to the appropriate value, so we only need to enable the QB_enable bit
			QB_enable_word = Create24BitWord(QB_ENABLE, REG_36h);
			sendWord_24Bit(QB_enable_word);

		}

		else if(MuteUntil_LockDetect){

			// Set the MuteUntilLockDetect Bit inside register 34h since QA didn't set it already
			Enable_MuteUntilLockDetect_WithoutQA_word = Create24BitWord(MUTE_UNTIL_LOCK_DETECT_WITHOUT_QA_ENABLED, REG_34h);
			sendWord_24Bit(Enable_MuteUntilLockDetect_WithoutQA_word);

			// Set the QB_enable pin
			QB_enable_word = Create24BitWord(QB_ENABLE, REG_36h);
			sendWord_24Bit(QB_enable_word);

		}

		else if(!MuteUntil_LockDetect){

			// Clear the MuteUntilLockDetect Bit inside register 34h since QA didn't do it already
			Disable_MuteUntilLockDetect_WithoutQA_word = Create24BitWord(DISABLE_MUTE_WITHOUT_QA_ENABLED, REG_34h);
			sendWord_24Bit(Disable_MuteUntilLockDetect_WithoutQA_word);

			// Set the QB_enable pin
			QB_enable_word = Create24BitWord(QB_ENABLE, REG_36h);
			sendWord_24Bit(QB_enable_word);

		}

	}

	unsigned long output_divider_word, output_divider_value;

	if(OutDoublerEnable){

		output_divider_value = OutDivider | OutputDoublerEnable;
		output_divider_word = Create24BitWord(output_divider_value, REG_3Bh);
		sendWord_24Bit(output_divider_word);
	}

	else{
		output_divider_word = Create24BitWord(OutDivider, REG_3Bh);
		sendWord_24Bit(output_divider_word);
	}



}




















void SetCalibrationVoltage(unsigned long CaliVoltage){

/*


                                                                    Additional Calibration Control Register Map

  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       ADDR       |        D7        |        D6        |        D5        |        D4        |        D3        |        D2        |        D1        |        D0        |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       003C       |      UNUSED      |      UNUSED      |      UNUSED      |      UNUSED      |  CaliVoltage<3>  |  CaliVoltage<2>  |  CaliVoltage<1>  |  CaliVoltage<0>  |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+


____________________________________________________________________

 Calibration Voltage Setting, sets Vc voltage during calibration

 0000 = 0.29V (default)
 0001 = 0.56V
 0010 = 0.83V
 0011 = 1.1V
 0100 = 1.37V
 0101 = 1.645V
 0110 = 1.915V
 0111 = 2.185V
 1000 = 2.455V
 1001 = 2.725V
 1010 = 3.0V

 1011 - 1111 = Unused

____________________________________________________________________


*/

	unsigned long CaliVoltage_word;

	CaliVoltage_word = Create24BitWord(CaliVoltage, REG_3Ch);

	sendWord_24Bit(CaliVoltage_word);



}




/*******************************************************************************************************/
/*     Takes in a status register keyword and send the status of that parameter back to the UART       */
/*******************************************************************************************************/


void ReadFromStatusRegisters(char* parameter){

/*
                                                    Status Register Map
    +------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+
    |      |             |             |             |             |             |             |             |             |
    | ADDR |     D7      |     D6      |     D5      |     D4      |     D3      |     D2      |     D1      |     D0      |
    |      |             |             |             |             |             |             |             |             |
    +----------------------------------------------------------------------------------------------------------------------+
    |      |             |             |             |             |             |             |             |             |
    | 0044 |   DigLock   | BandSelDone |   Unused    |   Unused    |  VcoSts<3>  |  VcoSts<2>  |  VcoSts<1>  |  VcoSts<0>  |
    |      |             |             |             |             |             |             |             |             |
    +----------------------------------------------------------------------------------------------------------------------+
    |      |             |             |             |             |             |             |             |             |
    | 0045 |   Unused    | BandSts<6>  | BandSts<5>  | BandSts<4>  | BandSts<3>  | BandSts<2>  | BandSts<1>  | BandSts<0>  |
    |      |             |             |             |             |             |             |             |             |
    +----------------------------------------------------------------------------------------------------------------------+
    |      |             |             |             |             |             |             |             |             |
    | 0046 |  Reserved   |  Reserved   |  Reserved   |  Reserved   |  Reserved   |  Reserved   |  Reserved   |  Reserved   |
    |      |             |             |             |             |             |             |             |             |
    +----------------------------------------------------------------------------------------------------------------------+
    |      |             |             |             |             |             |             |             |             |
    | 0047 |   Unused    |   Unused    |  Reserved   |  Reserved   | Reserved    |  Reserved   |  Reserved   |  Reserved   |
    |      |             |             |             |             |             |             |             |             |
    +----------------------------------------------------------------------------------------------------------------------+
    |      |             |             |             |             |             |             |             |             |
    | 0048 |   Unused    |   Unused    |   Unused    |   Unused    |   Unused    |   Unused    |   Unused    |   Unused    |
    |      |             |             |             |             |             |             |             |             |
    +----------------------------------------------------------------------------------------------------------------------+
    |      |             |             |             |             |             |             |             |             |
    | 0049 |   Unused    |   Unused    |   Unused    |   Unused    |   Unused    |   LossLock  |   Unused    |   Unused    |
    |      |             |             |             |             |             |             |             |             |
    +------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+-------------+

*/


	char temp[MAX_INPUT_LENGTH];
	char* temp_ptr = temp;

	unsigned long DigLockWord, BandSelectWord, currentVCO_Word, currentDigitalBandWord, lossOfLockWord;
	uint32_t DigLockValue, BandSelectValue, currentVCO_Value, currentDigitalBandValue, lossOfLockValue;

	clearArray(temp);

	// Copy character array into local workspace
	while(*parameter != '\0'){
		*temp_ptr = *parameter++;
		 temp_ptr++;
	}

	// Begin testing for particular commands
	if(!strncmp(temp, "DigLock", 7)){

		printString(newline);
		printString("Determining status of digital lock bit...");
		printString(newline);

		DigLockWord = Create24BitWord(0x00, REG_44h_READ);
		DigLockValue = GetRegisterValue(DigLockWord);

		// Isolate the Digital Lock bit
		DigLockValue &= BIT_7;

		if(DigLockValue){
			printString("PLL is locked.");
			printString(newline);
		}
		else{
			printString("PLL is NOT locked.");
			printString(newline);
		}
	}

	else if(!strncmp(temp, "BandSelectDone", 14)){

			printString(newline);
			printString("Determining if band selection has completed...");
			printString(newline);

			BandSelectWord = Create24BitWord(0x00, REG_44h_READ);
			BandSelectValue = GetRegisterValue(BandSelectWord);

			// Isolate the band selection done bit
			BandSelectValue &= BIT_6;

			if(BandSelectValue){
				printString("Band selection has completed.");
				printString(newline);
			}
			else{
				printString("Band selection has NOT completed.");
				printString(newline);
			}
	}

	else if(!strncmp(temp, "currentVCO", 10)){

			printString(newline);
			printString("Determining which VCO is active...");
			printString(newline);

			currentVCO_Word = Create24BitWord(0x00, REG_44h_READ);
			currentVCO_Value = GetRegisterValue(currentVCO_Word);

			// Isolate the VCO value bits
			currentVCO_Value &= BIT3_to_BIT0;

			printString("Current active VCO: VCO #");
			printInt(currentVCO_Value);
			printString(newline);
	}

	else if(!strncmp(temp, "currentDigitalBand", 18)){

			printString(newline);
			printString("Determining which digital band is active...");
			printString(newline);

			currentDigitalBandWord = Create24BitWord(0x00, REG_45h_READ);
			currentDigitalBandValue = GetRegisterValue(currentDigitalBandWord);

			// Isolate the digital band value bits
			currentDigitalBandValue &= BIT6_to_BIT0;

			printString("Current active digital band: Band ");
			printInt(currentDigitalBandValue);
			printString(newline);
	}

	else if(!strncmp(temp, "lossOfLock", 10)){

			printString(newline);
			printString("Determining whether digital lock has been lost...");
			printString(newline);

			lossOfLockWord = Create24BitWord(0x00, REG_49h_READ);
			lossOfLockValue = GetRegisterValue(lossOfLockWord);

			// Isolate the loss of digital lock bit
			lossOfLockValue &= BIT_2;

			if(lossOfLockValue){
				printString("Digital lock has been lost.");
				printString(newline);

				// Sticky bit; must write a '1' to clear
				lossOfLockWord = Create24BitWord(BIT_2, REG_49h_WRITE);
				sendWord_24Bit(lossOfLockWord);
			}
			else{
				printString("Digital lock is still active.");
				printString(newline);
			}
	}


}


void setVcoResolution(unsigned long bias_value){

/*

                                         VCO Resolution Control Register Map
  +------+------------+------------+------------+------------+------------+------------+------------+------------+
  |      |            |            |            |            |            |            |            |            |
  | ADDR |     D7     |     D6     |     D5     |     D4     |     D3     |     D2     |     D1     |     D0     |
  |      |            |            |            |            |            |            |            |            |
  +--------------------------------------------------------------------------------------------------------------+
  |      |            |            |            |            |            |            |            |            |
  | 0030 | vco_dac<7> | vco_dac<6> | vco_dac<5> | vco_dac<4> | vco_dac<3> | vco_dac<2> | vco_dac<1> | vco_dac<0> |
  |      |            |            |            |            |            |            |            |            |
  +------+------------+------------+------------+------------+------------+------------+------------+------------+


 VCO Bias DAC Setting (Resolution = 6.18mV / step)

 0000 0000 = 489 mV
 0000 0001 = 495.2 mV
 0000 0010 = 501.4 mV
 
 0110 0010 = 1.095 V (default)
 
 1111 1111 = 2.067 V

*/


	unsigned long VcoResolutionWord;

	VcoResolutionWord = Create24BitWord(bias_value, REG_30h);

	sendWord_24Bit(VcoResolutionWord);

}




