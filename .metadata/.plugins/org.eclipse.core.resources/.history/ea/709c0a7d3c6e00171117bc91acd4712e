/*
 * Synth_API_Control_Registers.c
 *
 *  Author: Mason Edgar
 */


#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include "inc/tm4c123gh6pm.h"
#include "inc/hw_adc.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_gpio.h"
#include "inc/hw_types.h"
#include "inc/hw_ssi.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/timer.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/debug.h"
#include "driverlib/adc.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/pwm.h"
#include "driverlib/ssi.h"
#include "Synth_API_Macro_Definitions.h"
#include "Synth_API_SPI_Setup.h"
#include "Synth_API_Control_Registers.h"



/***************************************************************************************************************************************/
/*                             Feedback Control Divider Registers
 *
 * The feedback divider N supports fractional division capability in the PLL feedback path. It consists
 * of an integer N divider of 16-bits, and a Fractional divider of 32-bits (FRAC) over 32-bits (MOD).
 * The 16 INT bits (Nint[15:0] in the Feedback Divider Control Registers) set the integer part of the
 * feedback division ratio. The 32 FRAC bits (Bit Nfrac[31:0] in the Feedback Divider Control Registers)
 * set the numerator of the fraction that goes into the Sigma Delta modulator. The 32 MOD bits
 * (Nmod[31:0] in the Feedback Divider Control Registers) set the denominator of the fraction that goes
 * into the Sigma Delta modulator.
 *
 *
 * FB Divider Integer Portion: Minimum divide ratio is 7d. Default is 31d
 *
 * FB Divider Fractional Portion: Nfrac is the numerator value of the fractional divide ratio. It is programmable from 0 to (Nmod - 1).
 *
 * FB divider Modulus Portion: Range is 2d - 4,294,967,295d. Default is 4,294,966,784d
 *
 */
/***************************************************************************************************************************************/



void SetFeedbackControlValues(unsigned short Nint, unsigned long Nfrac, unsigned long Nmod){

/*

	 Since the chip has 8-bit registers, the values for Nint, Nfrac, and Nmod are spread out across
	 multiple (consecutive) registers. The code below breaks each argument down into single-byte
	 pieces and sends them to their appropriate register.


                               Feedback Control Register Map (ADDR is in hex)

  +------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
  |            |           |           |           |           |           |           |           |           |
  |    ADDR    |    D7     |    D6     |    D5     |    D4     |    D3     |    D2     |    D1     |    D0     |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0010    |  Nint<7>  |  Nint<6>  |  Nint<5>  |  Nint<4>  |  Nint<3>  |  Nint<2>  |  Nint<1>  |  Nint<0>  |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0011    |  Nint<15> |  Nint<14> |  Nint<13> |  Nint<12> |  Nint<11> |  Nint<10> |  Nint<9>  |  Nint<8>  |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0012    |  Nfrac<7> |  Nfrac<6> |  Nfrac<5> |  Nfrac<4> |  Nfrac<3> |  Nfrac<2> |  Nfrac<1> |  Nfrac<0> |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0013    | Nfrac<15> | Nfrac<14> | Nfrac<13> | Nfrac<12> | Nfrac<11> | Nfrac<10> | Nfrac<9>  | Nfrac<8>  |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0014    | Nfrac<23> | Nfrac<22> | Nfrac<21> | Nfrac<20> | Nfrac<19> | Nfrac<18> | Nfrac<17> | Nfrac<16> |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0015    | Nfrac<31> | Nfrac<30> | Nfrac<29> | Nfrac<28> | Nfrac<27> | Nfrac<26> | Nfrac<25> | Nfrac<24> |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0016    |  Nmod<7>  |  Nmod<6>  |  Nmod<5>  |  Nmod<4>  |  Nmod<3>  |  Nmod<2>  |  Nmod<1>  |  Nmod<0>  |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0017    |  Nmod<15> |  Nmod<14> |  Nmod<13> |  Nmod<12> |  Nmod<11> |  Nmod<10> |  Nmod<9>  |  Nmod<8>  |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0018    |  Nmod<23> |  Nmod<22> |  Nmod<21> |  Nmod<20> |  Nmod<19> |  Nmod<18> |  Nmod<17> |  Nmod<16> |
  |            |           |           |           |           |           |           |           |           |
  +------------------------------------------------------------------------------------------------------------+
  |            |           |           |           |           |           |           |           |           |
  |    0019    |  Nmod<31> |  Nmod<30> |  Nmod<29> |  Nmod<28> |  Nmod<27> |  Nmod<26> |  Nmod<25> |  Nmod<24> |
  |            |           |           |           |           |           |           |           |           |
  +------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+

*/


	// Integer Portion
	unsigned long Nint_top, Nint_bottom, Nint_bottom_word, Nint_top_word;

	SplitNumber_16Bit(Nint, &Nint_top, &Nint_bottom);

	Nint_bottom_word = Create24BitWord(Nint_bottom, REG_10h);
	Nint_top_word = Create24BitWord(Nint_top, REG_11h);

	sendWord_24Bit(Nint_bottom_word);
	sendWord_24Bit(Nint_top_word);

	// Fractional Portion
	unsigned long Nfrac_top, Nfrac_upper_middle, Nfrac_lower_middle, Nfrac_bottom;
	unsigned long Nfrac_top_word, Nfrac_uppermiddle_word, Nfrac_lowermiddle_word, Nfrac_bottom_word;

	SplitNumber_32Bit(Nfrac, &Nfrac_top, &Nfrac_upper_middle, &Nfrac_lower_middle, &Nfrac_bottom);

	Nfrac_bottom_word = Create24BitWord(Nfrac_bottom, REG_12h);
	Nfrac_lowermiddle_word = Create24BitWord(Nfrac_lower_middle, REG_13h);
	Nfrac_uppermiddle_word = Create24BitWord(Nfrac_upper_middle, REG_14h);
	Nfrac_top_word = Create24BitWord(Nfrac_top, REG_15h);

	sendWord_24Bit(Nfrac_bottom_word);
	sendWord_24Bit(Nfrac_lowermiddle_word);
	sendWord_24Bit(Nfrac_uppermiddle_word);
	sendWord_24Bit(Nfrac_top_word);

	// Modulus Portion
	unsigned long Nmod_top, Nmod_upper_middle, Nmod_lower_middle, Nmod_bottom;
	unsigned long Nmod_top_word, Nmod_uppermiddle_word, Nmod_lowermiddle_word, Nmod_bottom_word;

	SplitNumber_32Bit(Nmod, &Nmod_top, &Nmod_upper_middle, &Nmod_lower_middle, &Nmod_bottom);

	Nmod_bottom_word = Create24BitWord(Nmod_bottom, REG_16h);
	Nmod_lowermiddle_word = Create24BitWord(Nmod_lower_middle, REG_17h);
	Nmod_uppermiddle_word = Create24BitWord(Nmod_upper_middle, REG_18h);
	Nmod_top_word = Create24BitWord(Nmod_top, REG_19h);

	sendWord_24Bit(Nmod_bottom_word);
	sendWord_24Bit(Nmod_lowermiddle_word);
	sendWord_24Bit(Nmod_uppermiddle_word);
	sendWord_24Bit(Nmod_top_word);

}



/*******************************************************************************************************/
/*                                   Setup the phase adjustment                                        */
/*******************************************************************************************************/

void SetPhaseAdjustment(unsigned long PhaseAdjustment){

/*


 The 8V97003 offers the possibility to adjust the phase delay between the outputs (RF_OUT/ nRF_OUT) and the input (REF_IN)
 of the device by shifting the output phase by a fraction of the size of the fractional denominator, when the part is used
 in fractional mode. Writing to the Phase Adjustment Control Registers triggers a phase shift (refer to below table).
 The phase adjustment value set by the bits, Phase[31:0], should be less than the fractional-N denominator register, MOD.
 The actual phase shift can be obtained with the following equation:




                                      Phase     T_pfd
 Phase Adjustment (degrees) =  360 X ------- X -------
                                       MOD      T_out


           OR

                                   Phase
 Phase Adjustment (ns) =  T_pfd X -------
                                    MOD



 Where 360° represents one cycle of output clock, T_pfd is the period at the input to the PFD (in ns), T_out is the period at the
 output of the 8V97003, and Phase is a programmable value, the same bit length as MOD.





                                                                        Phase Adjustment Register Map

  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       ADDR       |        D7        |        D6        |        D5        |        D4        |        D3        |        D2        |        D1        |        D0        |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       001A       |     Phase<7>     |     Phase<6>     |    Phase<5>      |    Phase<4>      |    Phase<3>      |    Phase<2>      |    Phase<1>      |    Phase<0>      |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       001B       |    Phase<15>     |    Phase<14>     |    Phase<13>     |    Phase<12>     |    Phase<11>     |    Phase<10>     |     Phase<9>     |     Phase<8>     |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       001C       |    Phase<23>     |    Phase<22>     |    Phase<21>     |    Phase<20>     |    Phase<19>     |    Phase<18>     |    Phase<17>     |    Phase<16>     |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       001D       |    Phase<31>     |    Phase<30>     |    Phase<29>     |    Phase<28>     |    Phase<27>     |    Phase<26>     |    Phase<25>     |    Phase<24>     |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+


*/

	unsigned long top, upper_middle, lower_middle, bottom;
	unsigned long top_word, upper_middle_word, lower_middle_word, bottom_word;

	SplitNumber_32Bit(PhaseAdjustment, &top, &upper_middle, &lower_middle, &bottom);

	bottom_word = Create24BitWord(bottom, REG_1Ah);
	lower_middle_word = Create24BitWord(lower_middle, REG_1Bh);
	upper_middle_word = Create24BitWord(upper_middle, REG_1Ch);
	top_word = Create24BitWord(top, REG_1Dh);

	sendWord_24Bit(bottom_word);
	sendWord_24Bit(lower_middle_word);
	sendWord_24Bit(upper_middle_word);
	sendWord_24Bit(top_word);


}


/*******************************************************************************************************************/
/*                                         Setup the Delta Sigma Modulator                                         */
/*******************************************************************************************************************/

void controlDSM(bool DSMtype, bool ShapeDitherEn, bool DitherEn, unsigned long DSMorder, unsigned long DitherGain){

/*

                                                       DSM Control Register Map (Delta Sigma Modulator)
  +---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
  |               |               |               |               |               |               |               |               |               |
  |     ADDR      |      D7       |      D6       |      D5       |      D4       |      D3       |      D2       |      D1       |      D0       |
  |               |               |               |               |               |               |               |               |               |
  +-----------------------------------------------------------------------------------------------------------------------------------------------+
  |               |               |               |               |               |               |               |               |               |
  |     001E      |    DSMType    |  DSMOrder<2>  |  DSMOrder<1>  |  DSMOrder<0>  |  DitherG<1>   |  DitherG<0>   | ShapeDitherEn |   DitherEn    |
  |               |               |               |               |               |               |               |               |               |
  +---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+


 In order to reduce the spurs, the user can enable the dither function to increase the repeat length of the code sequence in the Sigma Delta Modulator (DSM).
 The increased repeat length is 2^32 - 1 cycles so that the resulting quantization error is spread to appear like broadband noise. As a result, the
 in-band phase noise may be degraded when using the dither function. When the application requires the lowest possible phase noise and when the loop
 bandwidth is low enough to filter most of the undesirable spurs, or if the spurs won’t affect the system performance, it is recommended to use the low
 noise mode with dither disabled.



*/


	unsigned long DSMvalue, ShapeDitherEnValue, DitherEnValue, DSMshift, DitherGainshift, DSMresult, DSMword;

	if(DSMtype){ DSMvalue = BIT_7; }
	else if(!DSMtype){ DSMvalue = 0; }

	if(ShapeDitherEn){ ShapeDitherEnValue = BIT_1; }
	else if(!ShapeDitherEn){ ShapeDitherEnValue = 0; }

	if(DitherEn){ DitherEnValue = BIT_0; }
	else if(!DitherEn){ DitherEnValue = 0; }

	DSMshift = DSMorder << 4;

	DitherGainshift = DitherGain << 2;

	DSMresult = DSMvalue | ShapeDitherEnValue | DitherEnValue | DSMshift | DitherGainshift;

	DSMword = Create24BitWord(DSMresult, REG_1Eh);

	sendWord_24Bit(DSMword);

}



/*****************************************************************************************************************************/
/*                                            Setup the calibration control                                                  */
/*****************************************************************************************************************************/


void CalibrationControl(bool ForceRelock, bool PhaseAdjustTrigger, bool BandSelectDisable, unsigned long BandSelectAccuracy){


/*

                                                                     Calibration Control Register Map

  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       ADDR       |        D7        |        D6        |        D5        |        D4        |        D3        |        D2        |        D1        |        D0        |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       0021       |   ForceRelock    |   PhaseAdjTrig   |  BandSelDisable  |      UNUSED      |        0         |        0         |   BandSelAcc<1>  |   BandSelAcc<0>  |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+


____________________________________________________________________________

 ForceRelock

 0 = Normal operation (Default)
 1 = VCO forced to recalibrate.

 This bit is self-clearing.

____________________________________________________________________________

 Phase Adjust Trigger

 0 = Normal operation
 1 = Trigger phase adjustment once.

 This bit is self-clearing.

____________________________________________________________________________

 Band Select Disable

 This bit will prevent a VCO recalibration when registers 16:25 are written
   - Registers 16:25 are the feedback divider values Nint, Nfrac, & Nmod

 0 = VCO recalibrates when registers 16:25 are written
 1 = VCO does not recalibrate when registers 16:25 are written

____________________________________________________________________________

Band select/Calibration Accuracy

00 = 1x resolution
01 = 2x resolution
10 = 4x resolution
11 = 8x resolution (default)

____________________________________________________________________________



*/


	unsigned long FR_Part, PAT_Part, BSD_Part, Calibration, Calibration_word;

	// To reduce code complexity and size, i'm checking all three booleans individually and OR-ing them together at the end



	if(ForceRelock){ FR_Part = 0x80; } // Set the ForceRelock bit
	else if(!ForceRelock){ FR_Part = 0x00; }

	if(PhaseAdjustTrigger){PAT_Part = 0x40; } // Set the Phase Adjust Trigger bit
	else if(!PhaseAdjustTrigger){PAT_Part = 0x00; }

	if(BandSelectDisable){BSD_Part = 0x20; } // Set the Band Disable bit
	else if(!BandSelectDisable){ BSD_Part = 0x00; }

	Calibration = FR_Part | PAT_Part | BSD_Part | BandSelectAccuracy; // Put them all together to form the data byte

	Calibration_word = Create24BitWord(Calibration, REG_21h);

	sendWord_24Bit(Calibration_word);

}


/*******************************************************************************************************/
/*
 *                               Band Select Clock Divider Registers
 *
 *   Band Select Clock Divider:  Not Allowed: 0d
 *                               Default: 2,560d
 *                               Range: 1d - 131,071d
 *
 *   This ratio should be set so that F_pfd / BndSelDiv is < 100kHz.
 */
/*******************************************************************************************************/

void SetBandSelectClockDivider(unsigned short divider_value){


/*

                                                    Band Select Clock Diver Control Register Map

  +------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
  |      |                |                |                |                |                |                |                |                |
  | ADDR |       D7       |       D6       |       D5       |       D4       |       D3       |       D2       |       D1       |       D0       |
  |      |                |                |                |                |                |                |                |                |
  +----------------------------------------------------------------------------------------------------------------------------------------------+
  |      |                |                |                |                |                |                |                |                |
  | 0022 | BndSelDiv <07> | BndSelDiv <06> | BndSelDiv <05> | BndSelDiv <04> | BndSelDiv <03> | BndSelDiv <02> | BndSelDiv <01> | BndSelDiv <00> |
  |      |                |                |                |                |                |                |                |                |
  +----------------------------------------------------------------------------------------------------------------------------------------------+
  |      |                |                |                |                |                |                |                |                |
  | 0023 |     Unused     |     Unused     |     Unused     | BndSelDiv <12> | BndSelDiv <11> | BndSelDiv <10> | BndSelDiv <09> | BndSelDiv <08> |
  |      |                |                |                |                |                |                |                |                |
  +------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+



*/

	unsigned long upper, lower, upper_word, lower_word;

	SplitNumber_16Bit(divider_value, &upper, &lower);

	lower_word = Create24BitWord(lower, REG_22h);
	upper_word = Create24BitWord(upper, REG_23h);


	sendWord_24Bit(lower_word);
	sendWord_24Bit(upper_word);

}


/*****************************************************************************************************************************/
/*                                            Setup the lock detect registers                                                */
/*****************************************************************************************************************************/

void SetupLockDetect(bool Unlock_Detection, unsigned long LD_PinMode, unsigned long LD_Precision){

/*


                                                                        Lock Detect Control Register Map

  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       ADDR       |        D7        |        D6        |        D5        |        D4        |        D3        |        D2        |        D1        |        D0        |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       0026       |      UNUSED      |      UNUSED      |      UNUSED      |      UNUSED      | LDUnlockDetectEn |        0         |        0         |       0          |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  |       0027       |      UNUSED      |      UNUSED      |   LDPinMode<1>   |   LDPinMode<0>   |      UNUSED      |      LPD<2>      |      LPD<1>      |      LPD<0>      |
  |                  |                  |                  |                  |                  |                  |                  |                  |                  |
  +------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+------------------+


________________________________________________________________________

 Lock Detect - Unlock Detection

 0 = Disable (default)
 1 = Enable (a recalibration occurs if an unlock on LD is detected)

________________________________________________________________________

 LD Pin Mode

 00 = Digital Lock Detect (default); Normal lock detector function
 01 = Calibration done
 10 = Low
 11 = High

________________________________________________________________________

 Lock Detector Precision setting (ns)

 000 = 0.5 (default)
 001 = 1.0
 010 = 1.8
 011 = 3.0
 100 = 6.4
 101 = 6.4*
 110 = 10.4
 111 = 10.4*

 *The duplicate values are correct, according to the chip manufacturer.
          There are redundant settings for this parameter.
________________________________________________________________________


*/

	unsigned long unlock_detection_word, LD_PinMode_and_Precision, LD_PinMode_and_Precision_word;

	if(Unlock_Detection){

		unlock_detection_word = Create24BitWord(UNLOCK_DETECTION, REG_26h);
		sendWord_24Bit(unlock_detection_word);
	}

	else if(!Unlock_Detection){

		unlock_detection_word = Create24BitWord(NO_UNLOCK_DETECTION, REG_26h);
		sendWord_24Bit(unlock_detection_word);
	}

	LD_PinMode = LD_PinMode << 4;

	LD_PinMode_and_Precision = LD_PinMode | LD_Precision;

	LD_PinMode_and_Precision_word = Create24BitWord(LD_PinMode_and_Precision, REG_27h);

	sendWord_24Bit(LD_PinMode_and_Precision_word);


}
